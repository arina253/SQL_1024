--To update the data into products table
--To insert data into product sale table 

@@ROWCOUNT: return number of rows affected by the latest transaction.

CREATE TABLE StepDetail
(
 ProductId INT,
 Step_ID INT,
 Step_Desc VARCHAR(100),
 Row_Count INT,
 Insert_Date DATETIME
)

CREATE TABLE ErrorDetail
( 
 ProductId INT,
 Error_Desc VARCHAR(100),
 Insert_Date DATETIME
)
CREATE PROC Insert_Log
@ProductId INT,
@Step_ID INT,
@Step_Desc VARCHAR(100),
@Row_Count INT,
@Error_Desc VARCHAR(100)
AS
BEGIN 
 INSERT INTO StepDetail
 (
  ProductId ,
  Step_ID ,
  Step_Desc ,
  Row_Count ,
  Insert_Date 
 )
 VALUES
 (
 @ProductId ,
 @Step_ID ,
 @Step_Desc ,
 @Row_Count ,
 GETDATE()
 )

 INSERT INTO ErrorDetail
 (
  ProductId ,
  Error_Desc ,
  Insert_Date 
 )
 SELECT
  @ProductId ,
  @Error_Desc ,
  GETDATE() 
 WHERE @Error_Desc <> NULL OR @Error_Desc = ''

END


--EXECUTED STORED PROCEDURE BEFORE THE UPDATE COMMAND
--EXECUTED SP AFTER THE UPDATE COMMAND
--CAPTURING THE LOG BEFORE UPDATE AND AFTER UPDATE
--CAPTURING THE LOG BEFORE INSERT AND AFTER INSERT
--@@ROWACOUNT VARIABLE TO FIND THE NUMBER OF ROWS AFFECTED BY INSERT STATEMENT
-- WITHIN THE CATCH BLOCK, ERROR MESSAGE

SELECT *FROM TBLPRODUCT
SELECT *FROM TBLPRODUCTSALES
SELECT *FROM STEPDETAIL
SELECT *FROM ERRODETAIL

PROCEDURE WITHIN THE PROCEDURE

REQUIREMENTS:
--ERROR SHOULD GO INTO ERRORDETAIL TABLE.

--FOR ALL PROCEDURE WE USE LOG TABLE WHICH HOLDS EACH AND EVERY STEP AND AT WHICH STEP IT GOT FAILED.
--EXECUTION OF SP WITHIN ANOTHER SP.

--A COMMON TABLE FOR WORK WHICH WILL BE STORING DETAILS OF PROCEDURE ,STEPDETAIL TABLE OR ERROR DETAIL TABLE FOR AUDITING PURPOSE.
--EG: WE HAVE TAKEN AS PRODUCT ID AS REFERENCE TO INSERT DATA WHICH WILL BE UNIQUE WHICH WILL BE REFERENCING EXECUTION OF SP
--FOR THAT EXECUTION THERE WILL BE AUTOGENERATED EXECUTION NUMBER SO THAT WE CAN EASILY IDENTIFY FOR WHICH E.NO, SP GOT FAILED.

TO CAPTURE THE STEPDETAILS IN OUR SP
TO UPDATE DATA
TO INSERT DATA

TO CAPTURE ALL STEP DETAILS IN SOME AUDIT TABLES (STEPDETAIL - TO CAPTURE ALL THE INFO FOR THE ALL STEPS WITHIN THE PROC.
ERRORDETAIL -SPECIFIC TO ERROR ---HOLD THE DATA FOR ANY FAILURES TO CAPTURE ACTUAL ERROR MESSAGE/SQL EXCEPTION

CREATE STEPDETAIL AND ERRORDETAIL
COLUMNS LIKE STEP_ID,ROW_COUNT FOR HOW MANY ROWS AFFECTED
ERROR COLUMN HAVE ADDITIONAL COLUMN ERROR_DESC TO STORE THE ACTUAL ERROR MESSAGE

CREATE PROC TO INSERT DATA INTO STEPDETAIL AND ERRORDETAIL
ERRORDETAIL -INSERTING DATA INTO ERROR TABLE ONLY WHEN THERE IS ERROR AND ERROR DESC WILL HOLD MESSAGE FROM ERROR MESSAGE WITH WHEERE CONDITION

IF WE WANT TO CAPTURE SUCH INFORMATION, PROCESS WOULD BE LONGER WITHOUT SP.
CODE WILL BE REPEATING AND CONFUSING.

INSTEAD OF WRITING INSERT STATEMENT MULTIPLE TIMES, WE ARE WRITING INSERT STATEMENT INSIDE SP ONE TIME .TO BEGIN WITH SET ROW COUNT AS O.
NEED TO DECLARE VARIABLE AS THESE ARE NOT COMING FROM INPUT PARAMETER AND THESE VALUES ARE NEEDED TO PASS 
WHEN BEGIN TRANSACTION SET ROW COUNT AS O.
STEP ID 
INSERT DATA INTO STEP DEFINITION TABLE
WHEN UPDATE DONE, ROWS RETURNED WILL BE GIVEN BY @@ROWCOUNT.

IF NO ERROR WILL GO TO NEXT STEP: SECOND SET OF TRANSACTION.

ROLLBACK WILL EXECUTE WHEN THERE IS A FAILURE.
WE WILL CAPTURE STEPID  AND APPENDING FAILED TO STEP_DESC

**TRYING TO INSERT DUPLICATE VALUE AND PROCEDURE FAILED - COMMENTED @MAXPRODUCTSALESID

BEFORE PRODUCTION AND AFTER DEVELOPMENT, THERE WILL BE TESTING IN BETWEEN TO TEST THE ENTIRE LOGIC.
AS A DEVELOPER, WE WILL BE TESTING ON THE BASIS OF SUCCESS SCENARIOS.
FAILURE IN THE PRODUCTION DUE TO THE LACK OF BUSINESS REQUIREMENTS.
--WE MAINTAIN THE LOGS FOR THE PERIOD OF 10-20 YEARS AS PER THE BUSINESS POLICY.

----------------------------------------------------------------------------------------------------------------------------

--CLASS NOTES

--CAPTURE ALL STEP DETAILS IN SOME AUDIT TABLES
--STEPDETAIL TABLE - TO CAPTURE ALL THE INFO FOR ALL OF THE STEPS WITHIN THE PROC
--ERRORDETAIL TABLE - SPECIFIC TO ERROR - HOLD THE DATA FOR ANY FAILURES TO CAPTURE THE ACTUAL MESSAGE/SQL EXCEPTION
-- UPDATE AND INSERT

SELECT *FROM TBLPRODUCT
SELECT *FROM TBLPRODUCTSALES

CREATE OR ALTER PROC USP_SELLPRODUCT
	@PRODUCTID INT,
	@QUANTITYSOLD INT
AS
BEGIN
  --CHECK THE STOCK AVAILABLE, FOR THE PRODUCT WE WANT TO SELL
  DECLARE @STOCKAVAILABLE INT
  SELECT @STOCKAVAILABLE = QTYAVAILABLE FROM TBLPRODUCT WHERE PRODUCTID = @PRODUCTID

  --THROW AN ERROR TO THE CALLING APPLICATION,IF ENOUGH STOCK IS NOT AVAILABLE
  IF (@STOCKAVAILABLE < @QUANTITYSOLD)
  BEGIN
	RAISERROR ('NOT ENOUGH STOCK AVAILABLE', 16,1)
  END

  --IF ENOUGH STOCK AVAILABLE
  ELSE
  BEGIN
   BEGIN TRANSACTION
   --FIRST REDUCE THE QUANTITY AVAILABLE
   UPDATE TBLPRODUCT
   SET QTYAVAILABLE = (QTYAVAILABLE - @QUANTITYSOLD)
   WHERE PRODUCTID = @PRODUCTID

   DECLARE @MAXPRODUCTSALESID INT

   --CALCULATE MAXPRODUCTSALESID
   SELECT MAXPRODUCTSALESID = 
   CASE
	 WHEN MAX(PRODUCTSALESID)IS NULL THEN 0
	 ELSE MAX(PRODUCTSALESID)
	 END
	 FROM TBLPRODUCTSALES

	 --INCREMENT @MAXPRODUCTSALESID BY 1 SO WE DON'T GET A PRIMARY KEY VIOLATION
	 SET @MAXPRODUCTSALESID = @MAXPRODUCTSALESID + 1
	 
	 INSERT INTO TBLPRODUCTSALES(PRODUCTSALESID,PRODUCTID,QUANTITYSOLD) VALUES
	  (
	   @MAXPRODUCTSALESID,
	   @PRODUCTID,
	   @QUANTITYSOLD
	  )
	  COMMIT TRANSACTION
    END
END


CREATE OR ALTER PROCEDURE SPSELLPRODUCT
  @PRODUCTID INT,
  @QUANTITYTOSELL INT
AS
BEGIN

 DECLARE
  @STEP_ID INT = 0,
  @STEP_DESC VARCHAR(100),
  @ROW_COUNT INT,
  @ERROR_DESC VARCHAR(100)

 DECLARE @STOCKAVAILABLE INT
 SELECT @STOCKAVAILABLE = QTYAVAILABLE FROM TBLPRODUCT WHERE PRODUCTID = @PRODUCTID

 IF(@STOCKAVAILABLE < @QUANTITYTOSELL)
 BEGIN
	RAISERROR ('NOT ENOUGH STOCK AVAILABLE',16,1)
 END
 ELSE
 BEGIN
  BEGIN TRY
   BEGIN TRANSACTION

   SET @ROW_COUNT = 0
   SET @STEP_ID = @STEP_ID + 1
   SET @STEP_DESC = 'UPDATE PRODUCT QUANTITY IN PRODUCT TABLE'
   SET @ERROR_DESC = @@ERROR

   EXEC INSERT_LOG @PRODUCTID,@STEP_ID,@STEP_DESC,@ROW_COUNT,@ERROR_DESC

   UPDATE TBLPRODUCT
   SET QTYAVAILABLE = (QTYAVAILABLE - @QUANTITYTOSELL)
   WHERE PRODUCTID = @PRODUCTID

   SET @ROW_COUNT = @@ROWCOUNT
   SET @STEP_ID = @STEP_ID +1
   SET @STEP_DESC = @STEP_DESC + 'COMPLETED'
   SET @ERROR_DESC = @@ERROR

   EXEC INSERT_LOG @PRODUCTID,@STEP_ID,@STEP_DESC,@ROW_COUNT,@ERROR_DESC

   SET @ROW_COUNT=0
   SET @STEP_ID = @STEP_ID + 1
   SET @STEP_DESC = 'INSERT SALES DATA INTO PRODUCTSALES TABLE'
   SET @ERROR_DESC = @@ERROR

   EXEC INSERT_LOG @PRODUCTID,@STEP_ID,@STEP_DESC,@ROW_COUNT,@ERROR_DESC

   DECLARE @MAXPRODUCTSALESID INT
   SELECT @MAXPRODUCTSALESID = 
   CASE
	WHEN MAX(PRODUCTSALESID)IS NULL THEN 0
	ELSE MAX(PRODUCTSALESID)
	END
	FROM TBLPRODUCTSALES

	SET @MAXPRODUCTSALESID = @MAXPRODUCTSALESID + 1

	INSERT INTO TBLPRODUCTSALES VALUES
	(
	 @MAXPRODUCTSALESID,
	 @PRODUCTID,
	 @QUANTITYTOSELL,
	 GETDATE()
	 )

	 SET @ROW_COUNT = @@ROWCOUNT
	 SET @STEP_ID = @STEP_ID + 1
	 SET @STEP_DESC = @STEP_DESC + 'COMPLETED'
	 SET @ERROR_DESC = @@ERROR

	 EXEC INSERT_LOG @PRODUCTID,@STEP_ID,@STEP_DESC,@ROW_COUNT,@ERROR_DESC

	 COMMIT TRANSACTION
    END TRY
	BEGIN CATCH
	 ROLLBACK TRANSACTION

	SET @ROW_COUNT=@@ROWCOUNT
	SET @STEP_ID = @STEP_ID
	SET @STEP_DESC = @STEP_DESC + 'FAILED'
	SET @ERROR_DESC = ERROR_MESSAGE()
	--SELECT @ERROR_DESC

	EXEC INSERT_LOG @PRODUCTID,@STEP_ID,@STEP_DESC,@ROW_COUNT,@ERROR_DESC

	--SELECT
	--ERROR_NUMBER() AS ERRORNUMBER,
	--ERROR_MESSAGE() AS ERRORMESSAGE,
	--ERROR_PROCEDURE() AS ERRORPROCEDURE,
	--ERROR_STATE() AS ERRORSTATE,
	--ERROR_SEVERITY() AS ERRORSEVERITY,
	--ERROR_LINE() AS ERRORLINE
   END CATCH
 END
END

--SELECT @@ERROR
--SELECT @@ROWCOUNT

SELECT *FROM TBLPRODUCTSALES
SELECT *FROM TBLPRODUCT

SELECT *FROM STEPDETAIL
SELECT *FROM ERRORDETAIL

EXEC USP_SELLPRODUCT 1,20
EXEC USP_SELLPRODUCT 3,10
EXEC USP_SELLPRODUCT 2,200





