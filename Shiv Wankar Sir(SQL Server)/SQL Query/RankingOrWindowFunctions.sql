--SYSTEM FUNCTIONS
BUILT-IN FUNCTIONS 
USUALLY WORK WITH THE SQL SELECT STATEMENT

RANKING FUNCTIONS
RETURN A RANKING VALUE FOR EACH ROW IN A PARTITION.
RANK IS A SEQUENTIAL NUMBER PROVIDED TO EACH ROW BASED ON ASCENDING OR DESCENDING ORDER.
WE CAN GIVE UNIQUE NUMBER TO EACH ROWS IN A PARTITION.

1) ROW_NUMBER()
ASSIGN THE SEQUENTIAL NUMBER TO EACH UNIQUE RECORD PRESENT IN A PARTITION.
IF TWO EQUAL VALUES IN THE SAME PARTITION , IT WILL ASSIGN DIFFERENT NUMBER TO BOTH VALUES
RANK()
ASSIGN THE RANK NUMBER TO EACH RECORD PRESENT IN A PARTITION.
DENSE_RANKE()

CREATE TABLE Product_Sales(    
    Emp_Name VARCHAR(45) NOT NULL,    
    Year INT NOT NULL,  
    Country VARCHAR(45) NOT NULL,    
    Prod_name VARCHAR(45) NOT NULL,    
    Sales DECIMAL(12,2) NOT NULL,    
    PRIMARY KEY(Emp_Name, Year)    
);  

INSERT INTO Product_Sales(Emp_Name, Year, Country, Prod_name, Sales)   
VALUES('Mike Johnson', 2017, 'Britain', 'Laptop', 10000),    
('Mike Johnson', 2018, 'Britain', 'Laptop', 15000),    
('Mike Johnson', 2019, 'Britain', 'TV', 20000),    
('Mary Greenspan', 2017, 'Australia', 'Computer', 15000),    
('Mary Greenspan', 2018, 'Australia', 'Computer', 10000),    
('Mary Greenspan', 2019, 'Australia', 'TV', 20000),    
('Nancy Jackson', 2017, 'Canada', 'Mobile', 20000),    
('Nancy Jackson', 2018, 'Canada', 'Calculator', 1500),    
('Nancy Jackson', 2019, 'Canada', 'Mobile', 25000);

SELECT *FROM DBO.PRODUCT_SALES

SYNTAX FOR ROW NUMBER
SELECT ROW_NUMBER()OVER (PARTITION_BY COLUMN_NAME CLAUSE ORDER_BY_CLAUSE COLUMN_NAME) AS ROW_NUM FROM TABLE_NAME

--ROW NUM WITHOUT PARTITION BY
SELECT EMP_NAME,COUNTRY,PROD_NAME,ROW_NUMBER()OVER (ORDER BY PROD_NAME)
FROM DBO.PRODUCT_SALES

--ROW NUM WITH PARTITION BY
SELECT EMP_NAME,COUNTRY,PROD_NAME,ROW_NUMBER()OVER (PARTITION BY COUNTRY ORDER BY PROD_NAME)AS ROW_NUM 
FROM DBO.PRODUCT_SALES

IN PARTITION BY WE WILL TAKE COLUMN WHICH WE WANT TO GROUP BY.
PARTITION BY CLAUSE IS OPTIONAL, IF NOT PROVIDED CONSIDERED AS A SINGLE PARTITION.
--WE CAN USE ORDER BY CLAUSE WITH MAIN QUERY AS WELL.


RANK()SQL RANK FUNCTION
IF ENCOUNTERS TWO EQUAL VALUES IN THE SAME PATTITION THEN IT WILL ASSIGN THE SAME NUMBER TO BOTH VALUES AND IT SKIPS THE NEXT NUMBER.

SELECT RANK()OVER (PARTITION_BY COLUMN_NAME ORDER_BY_CLAUSE COLUMN_NAME) AS RANK_NUM FROM TABLE_NAME

SELECT EMP_NAME,COUNTRY,PROD_NAME,RANK()OVER (ORDER BY PROD_NAME)
FROM DBO.PRODUCT_SALES
--ONLY ORDER BY CLAUSE MATTERS TO GIVE RANK ()

--ROW NUM WITH PARTITION BY
SELECT EMP_NAME,COUNTRY,PROD_NAME,RANK()OVER (PARTITION BY COUNTRY ORDER BY PROD_NAME)AS RANK_NUM 
FROM DBO.PRODUCT_SALES

INSERT INTO DBO.PROFUCT_SALES VALUES
('NANCY JACKSON',2020,'CANADA','MOBILE',1000),
('NANCY JACKSON',2021,'CANADA','LAPTOP',1000)
('NANCY JACKSON',2020,'CANADA','MOBILE',1000)

('NANCY JACKSON',2020,'AUSTRALIA','CALCULATOR',1000)
('NANCY JACKSON',2020,'AUSTRALIA','COMPUTER',1000)




--3) SQL DENSE_RANK FUNCTION 
IF ENCOUNTERS TWO EQUAL VALUES IN THE SAME PARTITION, WILL ASSIGN THE SAME RANK NUMBER RO BOTH VALUES
 SIMILAR TO RANK() BUT IT WILL NOT SKIP THE RANK NUMBERS

 SELECT DENSE_RANK()OVER (PARTITION_BY COLUMN_NAME ORDER_BY_CLAUSE COLUMN_NAME) AS DENSE_RANK FROM TABLE_NAME

SELECT EMP_NAME,COUNTRY,PROD_NAME,DENSE_RANK()OVER (ORDER BY PROD_NAME)
FROM DBO.PRODUCT_SALES
--ONLY ORDER BY CLAUSE MATTERS TO GIVE RANK ()

--ROW NUM WITH PARTITION BY
SELECT EMP_NAME,COUNTRY,PROD_NAME,DENSE_RANK()OVER (PARTITION BY COUNTRY ORDER BY PROD_NAME)AS DENSE_RANK
FROM DBO.PRODUCT_SALES

--
SELECT EMP_NAME,COUNTRY,PROD_NAME,RANK()OVER (PARTITION BY COUNTRY ORDER BY COUNTRY)AS RANK_NUM 
FROM DBO.PRODUCT_SALES
--BETTER TO HAVE DIFFERENT  COLUMN IN PARTITION BY AND ORDER BY

SELECT *FROM DBO.EMPLOYEE

--FIND THE SECOND HIGHEST SALARY AND EMPLOYEE ID HOLDING SECOND HIGHEST SALARY

;WITH CTE
AS
(
SELECT ID,NAME,GENDER,SALARY,DENSE_RANK()OVER(ORDER BY SALARY DESC) AS SALARY_RANK
FROM DBO.EMPLOYEE 
)
SELECT *FROM CTE WHERE SALARY_RANK =2

SELECT id, salary AS Second_Highest_Salary
	FROM employee
	WHERE salary = (
    SELECT MAX(salary)
    FROM employee
    WHERE salary < (SELECT MAX(salary) FROM employee) )

	--GROUP BY CLAUSE WILL WORK ON ENTIRE TABLE

--4) SQL NTILE FUNCTION

**RANKING FUNCTION IS ALSO CALLED WINDOW FUNCTION.

ASSIGN THE RANK NUMBER TO 

SELECT NTILE(INTEGER_vALUE)OVER (PARTITION_BY_CLAUSE ORDER BY_CLAUSE)
PARTITION BY WORK FIRST AND WITHIN THE PARTITION IT WILL DIVIDE INTO GIVEN INTEGER VALUE.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--CLASS NOTES

--The below example will produce the average sales for each country and each year. Here we have specified more than one average by specifying multiple fields in the partition list.

SELECT Emp_Name, Year, Country, Prod_name, Sales, AVG(Sales)   
OVER(PARTITION BY Country, YEAR(Year)) as avg_sales_amount   
FROM Product_Sales; 

--The below statement explains the RANK() function by assigning numbering to each row based on the city:

SELECT * FROM dbo.Product_Sales

SELECT ROW_NUMBER() OVER (PARTITION_BY COLUMN_NAME Clause ORDER_BY_Clause COLUMN_NAME) AS ROW_NUM FROM TABLE_NAME

-- ROW NUM WITHOUT PARTITION BY
SELECT Emp_Name,Country,Prod_name, ROW_NUMBER() OVER (ORDER BY Prod_Name) AS ROW_NUM
FROM dbo.Product_Sales

-- ROW NUM WITH PARTITION BY
SELECT Emp_Name,Country,Prod_name, ROW_NUMBER() OVER (PARTITION BY Country ORDER BY Prod_Name) AS ROW_NUM
FROM dbo.Product_Sales

SELECT Emp_Name,Country,Prod_name, ROW_NUMBER() OVER (PARTITION BY Country ORDER BY Prod_Name) AS ROW_NUM
FROM dbo.Product_Sales
ORDER BY Country DESC

-- RANK()
SELECT RANK() OVER (PARTITION BY COLUMN_NAME ORDER BY Clause COLUMN_NAME) AS Rank_Num FROM TABLE_NAME

SELECT Emp_Name,Country,Prod_name, RANK() OVER (ORDER BY Prod_Name) AS Rank_Num
FROM dbo.Product_Sales

SELECT Emp_Name,Country,Prod_name, RANK() OVER (PARTITION BY Country ORDER BY Prod_Name) AS RANK_NUM
FROM dbo.Product_Sales

SELECT Emp_Name,Country,Prod_name, RANK() OVER (PARTITION BY Emp_Name ORDER BY Prod_Name) AS RANK_NUM
FROM dbo.Product_Sales


-- DENSE_RANK()
SELECT DENSE_RANK() OVER (PARTITION BY COLUMN_NAME ORDER BY Clause COLUMN_NAME) AS Rank_Num FROM TABLE_NAME

SELECT Emp_Name,Country,Prod_name, 
ROW_NUMBER() OVER (ORDER BY Prod_Name) AS ROW_Num,
RANK() OVER (ORDER BY Prod_Name) AS Rank_Num,
DENSE_RANK() OVER (ORDER BY Prod_Name) AS DenseRank_Num
FROM dbo.Product_Sales

SELECT Emp_Name,Country,Prod_name, 
ROW_NUMBER() OVER (PARTITION BY Country ORDER BY Prod_Name) AS ROW_Num,
RANK() OVER (PARTITION BY Country ORDER BY Prod_Name) AS Rank_Num,
DENSE_RANK() OVER (PARTITION BY Country ORDER BY Prod_Name) AS DenseRank_Num
FROM dbo.Product_Sales

SELECT Emp_Name,Country,Prod_name, 
ROW_NUMBER() OVER (PARTITION BY Country ORDER BY Prod_Name) AS ROW_Num,
RANK() OVER (PARTITION BY Country ORDER BY Prod_Name) AS Rank_Num,
DENSE_RANK() OVER (PARTITION BY Country ORDER BY Prod_Name) AS DenseRank_Num
FROM dbo.Product_Sales

-- NTILE
SELECT NTILE(Interger_Value) OVER (PARTITION_BY_Clause ORDER_BY_Clause)
FROM [Source]

SELECT Emp_Name,Country,Prod_name, NTILE(2) OVER (PARTITION BY COUNTRY ORDER BY Prod_Name DESC) AS NTILE_GRP
FROM dbo.Product_Sales

SELECT Emp_Name,Country,Prod_name, NTILE(2) OVER (ORDER BY Prod_Name) AS NTILE_GRP
FROM dbo.Product_Sales

SELECT Emp_Name,Prod_name,Country
FROM dbo.Product_Sales
GROUP BY Emp_Name,Prod_name,Country

SELECT Emp_Name,Country,Prod_name, RANK() OVER (PARTITION BY Emp_Name ORDER BY Prod_Name) AS DenseRank_Num
FROM dbo.Product_Sales

SELECT * FROM dbo.Employee

;WITH CTE
AS
(
SELECT ID,Name,Gender,Salary,DENSE_RANK() OVER (ORDER BY Salary DESC) AS Salary_Rank
FROM dbo.Employee
)

SELECT * FROM CTE WHERE Salary_Rank=2


SELECT * FROM dbo.Product_Sales
INSERT INTO dbo.Product_Sales VALUES 
('Nancy Jackson',2020,'Canada','Mobile',10000),
('Nancy Jackson',2021,'Canada','Laptop',10000),
('Nancy Jackson',2022,'Canada','Mobile',10000),
('Nancy Jackson',2023,'Australia','Calculator',10000),
('Nancy Jackson',2024,'Australia','Computer',10000)


-----------------------------

-----------------------------------------------
ROW_NUMBER() ----> SEQUENTIAL NUMBER RO EACH ROW
RANK() ---> SEQUENTIAL NUMBER TO EACH ROW,ASSIGN SAME RANK TO DUPLICATE RECORDS AND SKIPS THE NEXT RANK.
DENSE_RANK() ----> SEQUENTIAL NUMNER TO EACH ROW,ASSIGN THE SAME RAMK TO DUPLICATE RECORDS AD DOES NOT SKIP THE NEXT RANK
NTILE() ----> DIVIDE THE RESULT SET INTO 'N'OF PARTITIONS AND ASSIGN THE SEQUENTIAL RANK

LEAD()
LAG()
NOT ASSIGN ANY RANK TO EACH ROWS IN A TABLE
USED FOR CALCULATING RUNNING DIFFERENCE.
ALLOWS ACCESS TO A VALUE STORED IN A DIFFERENT ROW ABOVE THE CURRENT ROW.

SYNTAX:
LAG(EXPRESSION,[OFFSET],DEFAULT_VALUE])OVER (ORDER BY COLUMN)

EXPRESSION : NAME OF COLUMN ON WHICH WE ARE APPLYING LAG FUNCTION
OFFSET - NUMBER OF ROWS TO SKIP ABOVE
DEFAULT VALUE IS ALLOWED ONLY IF YOU SPECIFY THE SECOND PARAMETER.

CREATE TABLE dbo.SalesData
(
ID   INT,
Seller_Name VARCHAR(20),
Sale_Value MONEY
)
INSERT INTO dbo.SalesData VALUES
(3,'Stef',7000),
(1,'Alic',12000),
(2,'Mili',25000)

SELECT *FROM DBO.SALESDATA ORDER BY ID

--LAG
SELECT SELLER_NAME,SALE_VALUE,
LAG(SALE_VALUE)OVER (ORDER BY SALE_VALUE)AS PREVIOUS_sALE_VALUE
FROM DBO.SALESDATA

SELECT SELLER_NAME,SALE_VALUE,
LAG(SALE_VALUE,2,0)OVER (ORDER BY SALE_VALUE)AS PREVIOUS_sALE_VALUE
FROM DBO.SALESDATA

SELECT SELLER_NAME,SALE_VALUE,
LAG(SALE_VALUE,1,0)OVER (ORDER BY SALE_VALUE)AS PREVIOUS_sALE_VALUE
FROM DBO.SALESDATA

--LEAD()
ACCESSES A VALUES STORED IN A ROW BELOW THE CURRENT ROW.

SYNTAX:
LEAD(EXPRESSION,[OFFSET],DEFAULT_VALUE])OVER (ORDER BY COLUMN)

SELECT SELLER_NAME,SALE_VALUE,
LEAD(SALE_VALUE)OVER (ORDER BY SALE_VALUE)AS PREVIOUS_sALE_VALUE
FROM DBO.SALESDATA

SELECT SELLER_NAME,SALE_VALUE,
LEAD(SALE_VALUE,2,0)OVER (ORDER BY SALE_VALUE)AS PREVIOUS_sALE_VALUE
FROM DBO.SALESDATA

SELECT SELLER_NAME,SALE_VALUE,
LEAD(SALE_VALUE,1,0)OVER (ORDER BY SALE_VALUE)AS PREVIOUS_sALE_VALUE
FROM DBO.SALESDATA

--LEAD() AND LAG() USED IN GENERATING REPORT DATA 
--TO SEE THE DIFFERENCE IN THE SALE

CREATE TABLE dbo.SaleByYear
(
 SaleYear INT,
 TotalSales MONEY
)

INSERT INTO dbo.SaleByYear VALUES 
(2015,23000),
(2016,25000),
(2017,34000),
(2018,32000),
(2019,33000),
(2020,37000),
(2021,37000),
(2022,42000),
(2023,45000)

SELECT *FROM SALEBYYEAR

--DIFFERENCE IN THE TOTAL SALE

SELECT
SALEYEAR,
TOTALSALES AS CURRENT_TOTAL_sALE,
LAG(TOTALSALES)OVER(ORDER BY SALEYEAR)AS PREVIOUS_TOTAL_SALE,
TOTALSALES - LAG(TOTALSALES)OVER(ORDER BY SALEYEAR)AS DIFFERENCE
FROM DBO.SALEBYYEAR;

--LEAD AND LAG WITH OFFSET

CREATE TABLE dbo.EmpBonus
(
 EmpId INT,
 BonusYear INT,
 BonusQuar SMALLINT,
 BonusAmt DECIMAL
)

INSERT INTO dbo.EmpBonus VALUES
(1,2017,1,100),
(1,2017,2,250),
(1,2017,3,60),
(1,2017,4,20),
(1,2018,1,80),
(1,2018,2,80),
(1,2018,3,0),
(1,2018,4,0),
(1,2019,1,0),
(1,2019,2,100),
(1,2019,3,0),
(1,2019,4,150)

SELECT *FROM DBO.EMPBONUS

--WAHT IS THE BONUS FOR 2017 ,2018,2019 QUARTER 4?


SELECT
   BONUSYEAR,
   BONUSQUAR,
   LAG(BONUSAMT,4)OVER(ORDER BY BONUSYEAR,BONUSQUAR)AS PREVIOUS_BONUS,
   BONUSAMT AS CURRENT_BONUS,
   LEAD(BONUSAMT,4)OVER(ORDER BY BONUSYEAR,BONUSQUAR)AS NEXT_BONUS
FROM DBO.EMPBONUS
WHERE EMPID =1;

--USED FOR CALCULATING DIFFERENCE
--

SELECT
   BONUSYEAR,
   BONUSQUAR,
   LAG(BONUSAMT,4,0)OVER(PARTITION BY EMPID ORDER BY BONUSYEAR,BONUSQUAR)AS PREVIOUS_BONUS,
   BONUSAMT AS CURRENT_BONUS,
   LEAD(BONUSAMT,4,0)OVER(PARTITION BY EMPID ORDER BY BONUSYEAR,BONUSQUAR)AS NEXT_BONUS
FROM DBO.EMPBONUS

-------------------------------------------------------------------------------------------------------------------------------------------------------------------

--CLASS NOTES

DROP TABLE IF EXISTS dbo.SalesData
CREATE TABLE dbo.SalesData
(
ID   INT,
Seller_Name VARCHAR(20),
Sale_Value MONEY
)
INSERT INTO dbo.SalesData VALUES
(3,'Stef',7000),
(1,'Alic',12000),
(2,'Mili',25000)

SELECT * FROM dbo.SalesData ORDER BY ID

-- LAG
SELECT seller_name, sale_value,
  LAG(sale_value) OVER(ORDER BY sale_value) as previous_sale_value
FROM dbo.SalesData;

SELECT seller_name, sale_value,
  LAG(sale_value,1,0) OVER(ORDER BY sale_value) as previous_sale_value
FROM dbo.SalesData;

-- LEAD
SELECT seller_name, sale_value,
  LEAD(sale_value) OVER(ORDER BY sale_value) as next_sale_value
FROM dbo.SalesData;

SELECT seller_name, sale_value,
  LEAD(sale_value,1,0) OVER(ORDER BY sale_value DESC) as next_sale_value
FROM dbo.SalesData;

/*
Using LAG() and LEAD() to Compare Values
An important use for LAG() and LEAD() in reports is comparing the values in the current row with the 
values in the same column but in a row above or below.

Consider the following table, annual_sale, shown below:
*/
DROP TABLE IF EXISTS dbo.SaleByYear
CREATE TABLE dbo.SaleByYear
(
 SaleYear INT,
 TotalSales MONEY
)

INSERT INTO dbo.SaleByYear VALUES 
(2015,23000),
(2016,25000),
(2017,34000),
(2018,32000),
(2019,33000),
(2020,37000),
(2021,37000),
(2022,42000),
(2023,45000)

SELECT * FROM dbo.SaleByYear

SELECT 
   SaleYear,
   TotalSales AS current_total_sale,
   LAG(TotalSales) OVER(ORDER BY SaleYear) AS previous_total_sale,
   TotalSales - LAG(TotalSales) OVER(ORDER BY SaleYear) AS difference
FROM dbo.SaleByYear;

-- LEAD AND LAG WITH OFFSET
CREATE TABLE dbo.EmpBonus
(
 EmpId INT,
 BonusYear INT,
 BonusQuar SMALLINT,
 BonusAmt DECIMAL
)

INSERT INTO dbo.EmpBonus VALUES
(2,2017,1,100),
(2,2017,2,250),
(2,2017,3,60),
(2,2017,4,20),
(2,2018,1,80),
(2,2018,2,80),
(2,2018,3,0),
(2,2018,4,0),
(2,2019,1,0),
(2,2019,2,100),
(2,2019,3,0),
(2,2019,4,150)

--The query below selects the bonus for the employee with ID = 1 for each quarter of each year. 
--It then identifies the bonuses for the corresponding quarter in the year before and the year after.

SELECT * FROM dbo.EmpBonus

SELECT 
 EmpId,
 BonusYear, 
 BonusQuar, 
 LAG(BonusAmt,4,0) OVER(PARTITION BY EmpId ORDER BY BonusYear,BonusQuar) AS previous_bonus,
 BonusAmt AS current_bonus,