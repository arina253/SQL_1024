--INDEX IN SQL SERVER:

1
3
5
2
4
7
9
11
8
12
Search: 12
Search : 20
We cannot arrange existing data in sorted order.
Indexing says to arrange data in sorted manner in different memory called indexing memory.
1
2
3
4
5
7
8
9
11
12
Indexing goes with Binary Search method which says that divide data into two parts and compare search value is higher then go right else go left.
Divide 10 data into 2 parts 
Part 1 : 1,2,3,4,5        Part 2: 7,8,9,11,12
Search: 12
12 belongs to right side. Divide Part 2 into 2 parts:
Part 1: 7,8,9   Part 2: 11,12
Again divide Part 2 into 2 parts
Part1 : 11     Part 2: 12

Precondition for Binary Search
Always go with sorted data.

How?
Clustered index: 
Whenever we create a table and we create primary key inside a column, then clustered index gets created automatically.

We can create multiple columns in SQL Server and only one primary key.

If we want to create multiple index, we go with non clustered index.

Index means arranging data of existing table in sorted manner.
It is an option in SQL Server for faster search of query.


WE CAN REFER INDEX AND JUMP TO A REQUIRED PAGE LIKE SUMMARIZED DATA OF PAGE
A WAY TO SEARCH THINGS FASTER.
INDEX IS A FASTER WAY TO SEARCH DATA.
INDEXES ON TABLES - TO RETRIEVE DATA FROM THE DATABASE MORE QUICKLY.
END USERS CANNOT SEE THE INDEXES , THEY ARE USED JUST TO SPEED UP SEARCHES/QUERIES.
--THIS ARE USED TO FASTER RETRIEVAL OF THE DATA FROM A TABLE
--INDEXES ARE USED TO SPEED UP SEARCHES/QUERIES

--IF TABLE IS ALREADY CREATED AND WE WANT TO CREATE INDEX, WE USE FF SYNTAX:
--SYNTAX FOR INDEX
CREATE INDEX INDEX_NAME
ON TABLE_NAME(COLUMN1,COLUMN2,....)

NAMING - IX FOR INDEX,IX_TABLENAME_COLUMNNAME FOR GIVING NAME TO INDEX

SQL SERVER CLUSTERED INDEX
--WHENEVER WE DEFINE PRIMARY KEY ON A TABLE, IN A BACKGROUND CLUSTERED INDEX GETS CREATED ON THAT COLUMN AUTOMATICALLY
--UNDER INDEXES TAB IN TABLE NAME,WE CAN SEE CLUSTERED INDEX IF WE ARE USING PRIMARY KEY.

ALTER TABLE TABLE_NAME ADD PRIMARY KEY ()

SELECT INTO DBO.PRODUCTDEMO FROM ADVENTUREWORKS2022.PRODUCTION.PRODUCT


CREATE INDEX IX_PRODUCTDEMO_PRODUCTID
ON DBO.PRODUCTSDEMO(PRODUCTID)

IF HUGE DATA IN TABLE AND TAKING MUCH TIME TO EXECUTE, EG: LOADING AND TAKING MUCH TIME , WE HAVE TO GO TO THAT QUERY AND SEE WHAT ARE THE OPTIONS FOR QUERY OPTIMIZATION LIKE
JOIN USED IN PLACE OF SUBQUERY, WE CAN CREATE INDEXES ON COLUMN 

INDEXES USED TO HAVE OPTIMIZATION OF QUERY FOR FASTER PERFORMANCE OF QUERY
COLUMNS THAT WE ARE USING FREQUENTLY IN WHERE CLAUSE ARE CRITERIA TO USE COLUMN IN INDEX.
WHAT ARE THE COLUMNS WE ARE USING ON ON CLAUSE OF JOIN
A TABLE CAN HAVE MULTIPLE INDEXES.
IF THERE IS NO PRIMARY KEY ,WE CAN CREATE INDEX WITH CREATE STATEMENT AND IT IS NOT NECESSARY TO BE A PRIMARY KEY.

HOW MANY CLUSTERED INDEXES CAN BE CREATED IN A TABLE?
THERE WILL BE ONLY ONE CLUSTERED INDEX PER TABLE.
LIKE COMPOSITE PRIMARY KEY, WE CAN HAVE CLUSTERED INDEX ONLY ONE IN A TABLE 

B TREE STRUCTURE - DATA WILL BE DISTRIBUTED IN PAGES EQUALLY.EACH PAGE STORES 8 BYTES DATA
A TABLE IS STORING DATA IN B TREE STRUCTURE.
USED TO IMPROVE QUERY PERFORMANCE.
 TOO MANY INDEX WILL DECREASE QUERY PERFORMANCE.

 ONE CLUSTERED INDEX CAN BE CREATED PER TABLE AND ON MULTIPLE COLUMN.

 WE SHOULD HAVE PROPER INDEXES ON PROPER COLUMN

 COLUMNS TO CHOOSE FOR INDEX
 --WHATEVER THE COLUMN WE ARE WRITING IN WHERE CLAUSE MOSTLY ARE USED FOR INDEX
 -- WHATEVER COLUMN WE ARE USING ON CLAUSE IN JOIN
 --EXECUTION PLAN ALSO SUGGEST US TO CREATE INDEXES.

 ADVANTAGES:
 QUERY PERFORMANCE IS IMPROVED.
 REMOVES THE NEED FOR AN EXTRA LOOKUP, WE CAN DIRECTLY JUMP TO REQUIRED ROW.

 DISADVANTAGES:
 --MAINTENANCE OF INDEX STRUCTURE.
 --INDEXES CONSUME MORE MEMORY THAN OTHER OBJECTS, CAUSE OVERHEAD IN SQL SERVER.
 --TOO MANY INDEX REDUCE PERFORMANCE WHILE USING DML OPERATION(INSERT,UPDATE,DELETE)
 --THERE SHOULD BE AT LEAST ONE INDEX PER TABLE


 CREATE  CLUSTERED INDEX INDEX INDEX_NAME
ON TABLE_NAME(COLUMN1,COLUMN2,....)

WE  CAN ALTER AS WELL AS DROP INDEX

WHEN THERE IS A SCOPE OF QUERY PERFORMANCE AND QUERY IS TAKING LONG TIME TO EXECUTE THAT MEANS LOW QUERYPERFORMANCE, WE USE INDEXES.

MORE THAN ONE NON CLUSTERED INDEX CAN BE CREATED IN A TABLE.
WE CAN HAVE ONE CLUSTERED INDEX ON MULTIPLE COLUMN.

WE CAN HAVE MULTIPLE NON CLUSTERED INDEX PER TABLE AND ONLY ONE CLUSTERED INDEX PER TABLE.
NON CLUSTERED INDEX IS LIKE UNIQUE KEY AND WE CAN CREATE MULTIPLE NON CLUSTERED INDEX IN A TABLE.

IF WE WILL NOT MENTION ANY TYPE WHILE CREATING INDEX, THAT WILL BE NON CLUSTERED INDEX BY DEFAULT.

ONLY DIFFERENCE IS IN STORING DATA.
CLUSTERED INDEX IN B TREE

ACTUAL EXECUTION PLAN ICON IN TOP

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--Table scan
--Index seek

Different types of index:
CLUSTERED
NONCLUSTERED
UNIQUE CLUSTERED AND UNIQUE NONCLUSTERED

--NON CLUSTERED INDEX
--SIMILAR TO BOOKS.
--INDEX PAGE DOESN'T CONTAIN ACTUAL DATA.THEY ARE LIKE POINTERS.
--REQUIRES MORE SPACE TO STORE POINTERS AS WELL.
--A TABLE CAN HAVE MORE THAN ONE NON CLUSTERED INDEX.

--CLUSTERED INDEX IS FASTER THAN NON CLUSTERED INDEX BECAUSE DATA AND POINTER ARE IN THE SAME TABLE
--CLUSTERED INDEX DETERMINES THE STORAGE ORDER OF ROWS IN THE TABLE AND DOESN'T REQUIRE ADDITIONAL DISKSPACE BUT ADDITIONAL STORAGE SPACE REQUIRED IN NON CLUSTERED INDEX.

ADVANTAGE
HELPS TO RUN QUERIES FASTER AS DATA ARE ALREADY SORTED AND PERFORMANCE IMPROVED.
GROUP BY QUERIES CAN ALSO BENEFIT FROM INDEXES.

DISADVANTAGE:
ADDITIONAL DISK SPACE IN CASE OF NON CLUSTERED INDEX.
INSERT,UPDATE AND DELETE STATEMENTS CAN BECOME SLOW IF WE HAVE EXCESSIVE INDEXES

WHEN WE DEFINE PRIMARY KEY ON A COLUMN,DATA GETS SORTED AUTOMATICALLY DUE TO THE PRESENCE OF CLUSTERED INDEX.
--THERE IS A NEED TO CREATE NON CLUSTERED INDEX THOUGH CLUSTERED INDEX IS PRESENT WHEN ANY COLUMN IS USED MULTIPLE TIMES AND WE WANT TO HAVE FASTER SEARCH OF QUERY.

--IN NON CLUSTERED INDEX, WE ARE ABLE TO SEE ONLY INDEX POINTERS OR LOCATORS FOR DATA ROWS WHICH IS DIFFERENT THAN CLUSTERED INDEX.

SUMMARY
CAN USE NON CLUSTERED INDEX ON MULTIPLE COLUMN ON MULTIPLE CONDITIONS
NON CLUSTERED INDEX WILL CHECK KEY VALUES OR CLUSTERED VALUES.WHICH DENOTE ROW LOCATORS
KEY VALUES WILL JOIN TO CLUSTERED INDEX
--SQL ENGINE WILL SUGGEST INDEX WHEN DATA IS LARAGE

CLUSTERD/NON CLUSTERED INDEX, SQL ENGINE WILL JUMP TO INDEX SEEK.
NO INDEX ON COLUMN - THEN TABLE SCAN

INDEXES ARE IMPORTANT FROM PERFORMANCE POINT OF VIEW.FASTER RETRIEVAL OF DATA.TOO MUCH INDEX IS NOT USEFUL,HAVE PROBLEM DURING DML OPERATION.
WE SHOULD HAVE DEFINED INDEXES IN TABLE.WE CAN CHOOSE COLUMN IN WHERE CLAUSE, ON CLAUSE IN JOIN ----PRIMARY KEY COLUMN.

ONLY WHEN THERE IS A ISSUE IN PERFORMANCE ONLY NON CLUSTERED INDEX COEME IN PICTURE.
WHEN BUG REPORTED FROM PERFORMANCE POINT OF VIEW AFTER RUNNING APPLICATION.

UNIQUE INDEX IS SAME AS UNIQUE CONSTRAINT.
UNIQUE INDEX CAN BE UNIQUE CLUSTERED INDEX AND NON CLUSTERED UNIQUE INDEX
ALLOWED NO DUPLICATE DATA.

CREATE UNIQUE CLUSTERED INDEX INDEX_NAME
ON TABLE_NAME

SP_HELP- TO GET DATA ON ANY DATABASE OBJECTS
EXEC SP_HELP EMPLOYEES

 INDEX SEEK -WE KNOW EXACTLY WHERE TO GO.

 --------------------------------------------------------------------------------------------------------------------------------------------------------------------
 --CLASS WORK

 drop table [tblEmployee] 
CREATE TABLE [tblEmployee] 
( 
[Id] int, --Primary Key, 
[Name] nvarchar(50), 
[Salary] int, 
[Gender] nvarchar(10), 
[City] nvarchar(50) 
)

Insert into tblEmployee Values(3,'John',4500,'Male','New York') 
Insert into tblEmployee Values(1,'Sam',2500,'Male','London') 
Insert into tblEmployee Values(4,'Sara',5500,'Female','Tokyo') 
Insert into tblEmployee Values(5,'Todd',3100,'Male','Toronto') 
Insert into tblEmployee Values(2,'Pam',6500,'Female','Sydney') 

--SELECT * FROM tblEmployee
DROP INDEX tblEmployee.NIX_Emp_Name

CREATE NONCLUSTERED INDEX NIX_Emp_Name 
ON tblEmployee (Name DESC)

SELECT * FROM tblEmployee WHERE Name = 'John'

